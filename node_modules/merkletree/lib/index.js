'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.verifyProof = exports.proof = exports.computeTree = undefined;

var _binaryTree = require('./binary-tree.js');

var _crypto = require('crypto');

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var toBuffer = function toBuffer(value) {
  if (Buffer.isBuffer(value)) return value;
  return new Buffer(value);
};

var combine = function combine() {
  var hashAlgorithm = arguments.length <= 0 || arguments[0] === undefined ? 'sha256' : arguments[0];
  var encoding = arguments.length <= 1 || arguments[1] === undefined ? 'hex' : arguments[1];
  return function (leftData, rightData) {
    var hash = (0, _crypto.createHash)(hashAlgorithm);
    var input = Buffer.concat([toBuffer(leftData), toBuffer(rightData)]);
    return hash.update(input).digest(encoding);
  };
};

var computeTree = exports.computeTree = function computeTree(combineFn) {
  return function (leaves) {
    var tree = [].concat(_toConsumableArray(leaves.reverse()));
    var idx = 0;
    while (idx + 1 < tree.length) {
      tree.push(combineFn(tree[idx + 1], tree[idx]));
      idx = idx + 2;
    }
    return tree.reverse();
  };
};

// throws if leaf not found
var _proof = function _proof(tree) {
  return function (leafData) {
    var startIdx = (0, _binaryTree.findLeaf)(tree)(leafData);
    var proofArr = [];
    (0, _binaryTree.climb)(tree)(startIdx, function (data, idx) {
      var leftIdx = (0, _binaryTree.left)(tree)(idx);
      var rightIdx = (0, _binaryTree.right)(tree)(idx);
      proofArr.push({
        left: tree[leftIdx],
        parent: tree[idx],
        right: tree[rightIdx]
      });
    });
    return proofArr;
  };
};

exports.proof = _proof;
var verifyProof = exports.verifyProof = function verifyProof(leaf, expectedMerkleRoot) {
  var proofArr = arguments.length <= 2 || arguments[2] === undefined ? [] : arguments[2];

  var _ref = arguments.length <= 3 || arguments[3] === undefined ? {} : arguments[3];

  var hashAlgorithm = _ref.hashAlgorithm;
  var encoding = _ref.encoding;

  if (!proofArr.length) {
    if (leaf === expectedMerkleRoot) return true;
    return false;
  }
  var combineFn = combine(hashAlgorithm, encoding);

  // the merkle root should be the parent of the last part
  var actualMerkleRoot = proofArr[proofArr.length - 1].parent;

  if (actualMerkleRoot !== expectedMerkleRoot) {
    return false;
  }

  var prevParent = leaf;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = proofArr[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var part = _step.value;

      if (part.left !== prevParent && part.right !== prevParent) {
        //  prevParent is neither left or right value
        return false;
      }
      // Compute parent node
      var parentData = combineFn(part.left, part.right);
      // Parent in proof is incorrect
      if (parentData !== part.parent) {
        return false;
      }
      prevParent = parentData;
    }
    // Check one more time to be sure :P (this is not needed)
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return prevParent === expectedMerkleRoot;
};

exports.default = function (leaves) {
  var _ref2 = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var hashAlgorithm = _ref2.hashAlgorithm;
  var encoding = _ref2.encoding;

  var combineFn = combine(hashAlgorithm, encoding);
  var tree = computeTree(combineFn)(leaves);

  return {
    root: function root() {
      return tree[0];
    },
    proof: function proof(leaf) {
      return _proof(tree)(leaf);
    },
    leaves: function leaves() {
      return (0, _binaryTree.leaves)(tree);
    }
  };
};