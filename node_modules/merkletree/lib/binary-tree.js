"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

// Complete binary tree utility functions
// Using array representation explained at
// http://algoviz.org/OpenDSA/Books/OpenDSA/html/CompleteTree.html

// The number of nodes n in a complete binary tree can be found using this formula:
// n = 2l-1 where l is the number of leaf nodes in the tree.
var leafCountToNodeCount = exports.leafCountToNodeCount = function leafCountToNodeCount(leafCount) {
  return 2 * leafCount - 1;
};
var nodeCountToLeafCount = exports.nodeCountToLeafCount = function nodeCountToLeafCount(nodeCount) {
  return (nodeCount + 1) / 2;
};
var isInteriorNode = exports.isInteriorNode = function isInteriorNode(idx, nodeCount) {
  var leafCount = nodeCountToLeafCount(nodeCount);
  return idx >= 0 && idx < nodeCount - leafCount;
};

// Tree
var buildFromLeaves = exports.buildFromLeaves = function buildFromLeaves(leaves) {
  var leafCount = leaves.length;
  var nodeCount = leafCountToNodeCount(leaves.length);
  var delta = nodeCount - leafCount;
  return [].concat(_toConsumableArray(new Array(delta)), _toConsumableArray(leaves));
};

var leaves = exports.leaves = function leaves(tree) {
  var leafCount = nodeCountToLeafCount(tree.length);
  return tree.slice(-leafCount);
};

var root = exports.root = function root(tree) {
  return tree[0];
};

var levelOrder = exports.levelOrder = function levelOrder(tree) {
  return tree.map(function (val, idx) {
    return idx;
  });
};

// throws range error if idx returned is not within array range
var guardRange = function guardRange(tree) {
  return function (fn) {
    return function (idx) {
      // Guard
      var guard = function guard(i) {
        if (!(i >= 0 && i < tree.length)) {
          throw new RangeError();
        }
        return i;
      };
      return guard(fn(guard(idx)));
    };
  };
};
var parent = exports.parent = function parent(tree) {
  return guardRange(tree)(function (idx) {
    return Math.floor((idx - 1) / 2);
  });
};
var left = exports.left = function left(tree) {
  return guardRange(tree)(function (idx) {
    return 2 * idx + 1;
  });
};
var right = exports.right = function right(tree) {
  return guardRange(tree)(function (idx) {
    return 2 * idx + 2;
  });
};

var climb = exports.climb = function climb(tree) {
  return function (idx, fn) {
    if (idx === 0) {
      return;
    }
    var parentIdx = parent(tree)(idx);
    fn(tree[parentIdx], parentIdx);
    return climb(tree)(parentIdx, fn);
  };
};

var findLeaf = exports.findLeaf = function findLeaf(tree) {
  return function (leaf) {
    var leafCount = nodeCountToLeafCount(tree.length);
    for (var i = 0; i < leafCount; i++) {
      var idx = tree.length - 1 - i;
      if (tree[idx] === leaf) {
        return idx;
      }
    }
    return -1;
  };
};